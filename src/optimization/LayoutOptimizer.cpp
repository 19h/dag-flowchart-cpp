#include "optimization/LayoutOptimizer.h"
#include "layout/CoordinateConverter.h"
#include <cassert>
#include <numeric>

// ============================================================================
// OptimizationContext Helper Methods
// ============================================================================

/**
 * Resets the context for a new optimization phase.
 * Initializes variable groups to identity mapping (each block is its own group).
 */
void LayoutOptimizer::OptimizationContext::reset(size_t numBlocks) {
    variableGroups.resize(numBlocks);
    std::iota(variableGroups.begin(), variableGroups.end(), 0);
    solution.clear();
    equalities.clear();
    inequalities.clear();
    objective.clear();
    segments.clear();
    variableIndex = numBlocks;
    edgeIndex = 0;
}

/**
 * Sets the initial feasible value for a variable.
 * Expands the solution vector if necessary.
 */
void LayoutOptimizer::OptimizationContext::setFeasibleValue(size_t variable, int value) {
    solution.resize(std::max(solution.size(), variable + 1));
    solution[variable] = value;
}

/**
 * Adds objective terms to minimize distance between two variables.
 * The direction is determined by comparing current positions.
 */
void LayoutOptimizer::OptimizationContext::addToObjective(size_t a, int posA, size_t b, int posB) {
    objective.resize(std::max(objective.size(), std::max(a, b) + 1));
    if (posA < posB) {
        // Minimize b - a (make b smaller, a larger)
        objective[b] += 1;
        objective[a] -= 1;
    } else {
        // Minimize a - b (make a smaller, b larger)
        objective[a] += 1;
        objective[b] -= 1;
    }
}

// ============================================================================
// Public API
// ============================================================================

/**
 * Main optimization entry point.
 * Performs vertical then horizontal optimization in sequence.
 */
void LayoutOptimizer::optimize(LayoutState& state) const {
    OptimizationContext ctx;
    initializeBlockMapping(state, ctx);
    optimizeVertical(state, ctx);
    ctx.reset(ctx.blockMapping.size());
    optimizeHorizontal(state, ctx);
}

// ============================================================================
// Initialization
// ============================================================================

/**
 * Creates a mapping from block IDs to variable indices.
 * Variables 0..N-1 represent block positions; edge variables come after.
 */
void LayoutOptimizer::initializeBlockMapping(LayoutState& state, OptimizationContext& ctx) const {
    size_t blockIndex = 0;
    for (auto& blockIt : *state.blocks) {
        ctx.blockMapping[blockIt.first] = blockIndex++;
    }
    ctx.variableGroups.resize(ctx.blockMapping.size());
    std::iota(ctx.variableGroups.begin(), ctx.variableGroups.end(), 0);
}

// ============================================================================
// Vertical Optimization (Y-axis)
// ============================================================================

/**
 * Optimizes Y coordinates of blocks and horizontal edge segments.
 *
 * Variables:
 * - [0..N-1]: Block Y positions
 * - [N..]: Horizontal edge segment Y positions
 *
 * Constraints:
 * - Parent Y + height + spacing <= Child Y (for downward edges)
 * - Non-overlapping segments (generated by sweep-line)
 *
 * Objective:
 * - Minimize total Y (push everything up)
 * - Minimize edge segment bends (consecutive segments pull toward each other)
 */
void LayoutOptimizer::optimizeVertical(LayoutState& state, OptimizationContext& ctx) const {
    ctx.segments.reserve(state.blocks->size() * 4);
    ctx.variableIndex = ctx.blockMapping.size();
    ctx.edgeIndex = 0;
    
    // Base objective: minimize all block Y positions (push upward)
    ctx.objective.assign(ctx.blockMapping.size(), 1);

    // ---- Process each block and its edges ----
    for (auto& blockIt : *state.blocks) {
        auto& block = blockIt.second;
        int blockVariable = ctx.blockMapping[blockIt.first];

        for (auto& edge : block.edges) {
            auto& targetBlock = (*state.blocks)[edge.target];
            
            // Constraint: parent must be above child (with spacing)
            if (block.y < targetBlock.y) {
                int spacing = block.height + config_.blockVerticalSpacing;
                ctx.inequalities.push_back({{blockVariable, ctx.blockMapping[edge.target]}, -spacing});
            }

            // Create variables for horizontal edge segments
            if (edge.polyline.size() >= 3) {
                for (size_t i = 2; i < edge.polyline.size(); i += 2) {
                    // Extract segment bounds (note: x/y swapped for horizontal segments)
                    int y0 = edge.polyline[i - 1].x;
                    int y1 = edge.polyline[i].x;
                    if (y0 > y1) std::swap(y0, y1);

                    int x = edge.polyline[i].y;
                    
                    // Create segment for sweep-line
                    ctx.segments.push_back({x, int(ctx.variableIndex), y0, y1});
                    ctx.variableGroups.push_back(ctx.blockMapping.size() + ctx.edgeIndex);
                    ctx.setFeasibleValue(ctx.variableIndex, x);

                    // Objective: minimize distance to previous segment (straighten edge)
                    if (i > 2) {
                        int prevX = edge.polyline[i - 2].y;
                        ctx.addToObjective(ctx.variableIndex, x, ctx.variableIndex - 1, prevX);
                    }
                    ctx.variableIndex++;
                }
                ctx.edgeIndex++;
            }
        }

        // Add block as two segments (top and bottom)
        ctx.segments.push_back({block.y, blockVariable, block.x, block.x + block.width});
        ctx.segments.push_back({block.y + block.height, blockVariable, block.x, block.x + block.width});
        ctx.setFeasibleValue(blockVariable, block.y);
    }

    // ---- Generate non-overlapping constraints from segments ----
    createInequalitiesFromSegments(std::move(ctx.segments), ctx.solution, ctx.variableGroups,
                                  ctx.blockMapping.size(), config_.blockVerticalSpacing,
                                  config_.edgeVerticalSpacing, ctx.inequalities);

    // ---- Solve LP and apply results ----
    ctx.objective.resize(ctx.solution.size());
    optimizeLinearProgram(ctx.solution.size(), ctx.objective, ctx.inequalities, ctx.equalities, ctx.solution);
    applyPositions(state, ctx, true);
    
    // Reconnect edge endpoints to block boundaries
    CoordinateConverter::connectEdgeEnds(*state.blocks);
}

// ============================================================================
// Horizontal Optimization (X-axis)
// ============================================================================

/**
 * Optimizes X coordinates of blocks and vertical edge segments.
 *
 * Variables:
 * - [0..N-1]: Block X positions
 * - [N..]: Vertical edge segment X positions
 *
 * Constraints:
 * - Edge segments attached to blocks (equality constraints)
 * - Non-overlapping segments (generated by sweep-line)
 * - Parent centered between children (for blocks with exactly 2 children)
 *
 * Objective:
 * - Minimize edge segment bends (consecutive segments pull toward each other)
 */
void LayoutOptimizer::optimizeHorizontal(LayoutState& state, OptimizationContext& ctx) const {
    ctx.variableIndex = ctx.blockMapping.size();
    ctx.edgeIndex = 0;

    // ---- Helper: Create equality constraint linking edge to block ----
    auto addBlockSegmentEquality = [&](uint64_t blockId, int edgeVariable, int edgeVariablePos) {
        int blockPos = (*state.blocks)[blockId].x;
        int blockVariable = ctx.blockMapping[blockId];
        // block_x - edge_x = blockPos - edgeVariablePos
        ctx.equalities.push_back({{blockVariable, edgeVariable}, blockPos - edgeVariablePos});
    };

    // ---- Helper: Create inequality constraint ----
    auto addInequality = [&](size_t a, int posA, size_t b, int posB, int minSpacing) {
        ctx.inequalities.push_back(createInequality(a, posA, b, posB, minSpacing, ctx.solution));
    };

    // ---- Process each block and its edges ----
    for (auto& blockIt : *state.blocks) {
        auto& block = blockIt.second;

        for (auto& edge : block.edges) {
            if (edge.polyline.size() < 2) continue;

            size_t firstEdgeVariable = ctx.variableIndex;
            
            // Create variables for vertical edge segments
            for (size_t i = 1; i < edge.polyline.size(); i += 2) {
                int y0 = edge.polyline[i - 1].y;
                int y1 = edge.polyline[i].y;
                if (y0 > y1) std::swap(y0, y1);

                int x = edge.polyline[i].x;
                
                // Create segment for sweep-line
                ctx.segments.push_back({x, int(ctx.variableIndex), y0, y1});
                ctx.variableGroups.push_back(ctx.blockMapping.size() + ctx.edgeIndex);
                ctx.setFeasibleValue(ctx.variableIndex, x);

                // Objective: minimize distance to previous segment (straighten edge)
                if (i > 2) {
                    int prevX = edge.polyline[i - 2].x;
                    ctx.addToObjective(ctx.variableIndex, x, ctx.variableIndex - 1, prevX);
                }
                ctx.variableIndex++;
            }

            // Equality constraints: edge endpoints must stay attached to blocks
            size_t lastEdgeVariableIndex = ctx.variableIndex - 1;
            addBlockSegmentEquality(blockIt.first, firstEdgeVariable, edge.polyline[1].x);
            addBlockSegmentEquality(edge.target, lastEdgeVariableIndex, ctx.segments.back().x);
            ctx.edgeIndex++;
        }

        // Add block as two segments (left and right edges)
        int blockVariable = ctx.blockMapping[blockIt.first];
        ctx.segments.push_back({block.x, blockVariable, block.y, block.y + block.height});
        ctx.segments.push_back({block.x + block.width, blockVariable, block.y, block.y + block.height});
        ctx.setFeasibleValue(blockVariable, block.x);
    }

    // ---- Generate non-overlapping constraints from segments ----
    createInequalitiesFromSegments(std::move(ctx.segments), ctx.solution, ctx.variableGroups,
                                  ctx.blockMapping.size(), config_.blockHorizontalSpacing,
                                  config_.edgeHorizontalSpacing, ctx.inequalities);

    ctx.objective.resize(ctx.solution.size());

    // ---- Add centering constraints for blocks with exactly 2 children ----
    for (auto& blockIt : *state.blocks) {
        auto& block = blockIt.second;
        int blockVariable = ctx.blockMapping[blockIt.first];

        if (block.edges.size() == 2) {
            auto& blockLeft = (*state.blocks)[block.edges[0].target];
            auto& blockRight = (*state.blocks)[block.edges[1].target];
            auto middle = block.x + block.width / 2;

            // Only add centering if children are actually on opposite sides
            if (blockLeft.x + blockLeft.width < middle && blockRight.x > middle) {
                // Parent center must be between children (with half spacing)
                addInequality(ctx.blockMapping[block.edges[0].target], blockLeft.x + blockLeft.width,
                            blockVariable, middle, config_.blockHorizontalSpacing / 2);
                addInequality(blockVariable, middle, ctx.blockMapping[block.edges[1].target],
                            blockRight.x, config_.blockHorizontalSpacing / 2);

                // If this block has a merge point, align centers
                auto& gridBlock = state.grid_blocks[blockIt.first];
                if (gridBlock.mergeBlock) {
                    auto& mergeBlock = (*state.blocks)[gridBlock.mergeBlock];
                    if (mergeBlock.x + mergeBlock.width / 2 == middle) {
                        ctx.equalities.push_back(
                            {{blockVariable, ctx.blockMapping[gridBlock.mergeBlock]},
                             block.x - mergeBlock.x});
                    }
                }
            }
        }
    }

    // ---- Solve LP and apply results ----
    optimizeLinearProgram(ctx.solution.size(), ctx.objective, ctx.inequalities, ctx.equalities, ctx.solution);
    applyPositions(state, ctx, false);
}

// ============================================================================
// Solution Application
// ============================================================================

/**
 * Applies optimized positions from solution vector to blocks and edges.
 *
 * For vertical optimization (horizontal=true): updates Y coordinates
 * For horizontal optimization (horizontal=false): updates X coordinates
 */
void LayoutOptimizer::applyPositions(LayoutState& state, const OptimizationContext& ctx, bool horizontal) const {
#ifndef NDEBUG
    // Verify all positions are non-negative
    for (auto v : ctx.solution) {
        assert(v >= 0);
    }
#endif
    
    size_t variableIndex = ctx.blockMapping.size();
    
    // Apply edge segment positions
    for (auto& blockIt : *state.blocks) {
        auto& block = blockIt.second;
        for (auto& edge : block.edges) {
            // Start index differs for horizontal vs vertical
            for (size_t i = 1 + int(horizontal); i < edge.polyline.size(); i += 2) {
                int x = ctx.solution[variableIndex++];
                if (horizontal) {
                    // Vertical optimization: update Y of horizontal segments
                    edge.polyline[i].ry() = x;
                    edge.polyline[i - 1].ry() = x;
                } else {
                    // Horizontal optimization: update X of vertical segments
                    edge.polyline[i].rx() = x;
                    edge.polyline[i - 1].rx() = x;
                }
            }
        }
        
        // Apply block position
        int blockVariable = ctx.blockMapping.at(blockIt.first);
        (horizontal ? block.y : block.x) = ctx.solution[blockVariable];
    }
}
